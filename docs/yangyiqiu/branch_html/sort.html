<!DOCTYPE html>
<html>
    <meta name="description" content="暘壹專屬高級網站" />
    <meta name="author" content="邱暘壹" />
    <meta name="keyword" content="邱暘壹,林奕安,yangyiqiu" />

    
    <meta property="og:type" content="article" />

    <!-- 網頁標題或是顯示內容的標題 -->
    <meta property="og:title" content="自訂網頁在Facebook, Google+等社群平台的顯示內容" />

    <!-- 網頁內容的簡單說明、建議以二至四句話來說明。 -->
    <meta property="og:description"
        content="透過社群分享中繼標籤，我們可以優化顯示在社群網站上的內容，包含標題、縮圖、說明文字、作者…等，還有其他豐富的訊息。這篇文章就要教你如何使用社群分享中繼標籤來自訂顯示在社群網站上的分享訊息。" />

    <!-- 分享的縮圖(網頁的預覽圖) -->
    <meta property="og:image" content="http://blog.shihshih.com/social-meta-tag/demo/images/social-sharing.png" />

    <!-- 網頁的唯一網址canonical URL。如果您有手機版和電腦版二個網頁、將二個網頁的og:url設成電腦版的網址，兩個網頁的facebook按讚次數就可以加總統計在一起。 -->
    <meta property="og:url" content="http://blog.shihshih.com/social-meta-tag/" />
   
    <!-- 連結style.css樣式表 -->
    <link rel="stylesheet" href="style.css" type="text/css">

    <title>暘壹專屬高級網站</title>

<head>

</head>

<body>
    <pre>
    #include <iostream>
using namespace std;

void swap(int &a, int &b);
void serchigsort(int *arr, int n);
void selectionsort(int *arr, int n);
void bubblesort(int *arr, int n);
void insertionsort(int *arr, int n);
void shellsort(int *arr, int n);
void qicksort(int *arr, int left, int right);

int main()
{
    int a[9] = {1, 4, 3, 5, 7, 6, 2, 1, 6};
    // serchigsort(a,sizeof(a)/sizeof(a[0]));
    // selectionsort(a,sizeof(a)/sizeof(a[0]));
    // bubblesort(a,sizeof(a)/sizeof(a[0]));
    // insertionsort(a,sizeof(a)/sizeof(a[0]));
    // shellsort(a, sizeof(a) / sizeof(a[0]));
    qicksort(a, 0, 8);

    for (int i = 0; i < 9; i++)
    {
        cout << a[i];
    }
}

void swap(int &a, int &b)
{
    int temp = a;
    a = b;
    b = temp;
}

// 先找到陣列中的最大最小直
// 要確定順序的位置為count
// 從最小值到最大值回圈，看陣列中有沒有一樣的
// 有的話就和 arr[count] 互換，arr[count] 就會是最小值
// count++
void serchigsort(int *arr, int n)
{
    int maxnum = INT_MIN;
    int mininum = INT_MAX;
    // 先找到陣列中的最大最小直
    for (int i = 0; i < n; i++)
    {
        if (arr[i] > maxnum)
            maxnum = arr[i];
        if (arr[i] < mininum)
            mininum = arr[i];
    }
    // 要確定順序的位置為count
    int count = 0;
    // 從最小值到最大值回圈，看陣列中有沒有一樣的
    for (int i = mininum; i <= maxnum; i++)
    {
        for (int j = 0; j < n; j++)
        {
            // 有的話就和 arr[count] 互換，arr[count] 就會是最小值
            if (arr[j] == i)
            {
                swap(arr[j], arr[count]);
                // count++
                count++;
            }
        }
    }
}

// https://www.runoob.com/w3cnote/selection-sort.html
// 設要確定排序的第i個位置的數 arr[i] 設為 minindex
// 從 i+1 利用 minindex 開始找最小值
// 最後再把最小值與 arr[i] 互換
// 第i個位置就確定了
void selectionsort(int *arr, int n)
{
    for (int i = 0; i < n - 1; i++)
    {
        // 設要確定排序的第i個位置 設為 minindex
        int minindex = i;
        // 從 i+1 利用 minindex 開始找最小值
        for (int j = i + 1; j < n; j++)
        {
            if (arr[j] < arr[minindex])
            {
                minindex = j;
            }
        }
        // 最後再把最小值與 arr[i] 互換
        swap(arr[i], arr[minindex]);
    }
}

// https://www.runoob.com/w3cnote/bubble-sort.html
// 要確定排序的是倒數第i個
// 比較左右兩數，如果第一個比第二個大，就交換他們兩個
// 針對所有元素重複這個動作，除了排好序的，與扣掉排好序的後最後一個
void bubblesort(int *arr, int n)
{
    // 要確定排序的是倒數第i個
    for (int i = 0; i < n - 1; i++)
    {
        // 針對所有元素重複這個動作，除了排好序的，與扣掉排好序的後最後一個
        for (int j = 0; j < n - i - 1; j++)
        {
            // 比較左右兩數，如果第一個比第二個大，就交換他們兩個
            if (arr[j] > arr[j + 1])
            {
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}

// 把第一個元素當作已知有序序列，從第二個元素開始做
// 把要做插入的元素設為flag
// 從flag開始往前找，當flag小於前面有序陣列的元素，把該元素往右移一格
// 檢查下一個元素
// 當flag大於檢查的元素，放在上次被移走的元素原本的位置，等於現在檢查的元素的右邊
void insertionsort(int *arr, int n)
{
    // 把第一個元素當作已知有序序列，從第二個元素開始做
    for (int i = 1; i < n; i++)
    {
        // 把要做插入的元素設為flag
        int flag = arr[i];
        // 從flag開始往前找，當flag小於前面有序陣列的元素，把該元素往右移一格
        int j = i - 1;
        while (j >= 0 && flag < arr[j])
        {
            arr[j + 1] = arr[j];
            // 檢查下一個元素
            j--;
        }
        // 當flag大於檢查的元素，放在上次被移走的元素原本的位置，等於現在檢查的元素的右邊
        arr[j + 1] = flag;
    }
}

// https://ithelp.ithome.com.tw/articles/10277847
// 由大到小定數個 gap ，最後 gap 一定要是一
// 利用 gap 分組做 insertion sort 跨gap為一組
// 例如
// 14276389
// gap 4
// 組別分別為 1,6。4,7。2,8。7,9。
// 做 insertion sort
void shellsort(int *arr, int n)
{
    for (int gap = n / 2; gap > 0; gap /= 2)
    {
        // 把第一個 gap 的元素當已知有序序列
        // 從後面一個個一gap分的組別做 insertion sort
        for (int i = gap; i < n; i++)
        {
            int temp = arr[i];
            int j;
            for (j = i - gap; j >= 0 && arr[j] > arr[i]; j -= gap)
            {
                arr[j + gap] = arr[j];
            }
            arr[j + gap] = temp;
        }
    }
}

// 以最右邊基準點
// 分別從左右開始找
// 左邊要放小於等於 flag 的，所以找比 flag 大的 ， 找到時 i 指在上面
// 右邊要放大於 flag 的，所以找比 flag 小的 ， 找到時 j 指在上面
// 交換 i j 
// 重複直到 i j 重合
// i j 重合後與 flag 位置互換，這時flag左邊都是比她小的，右邊都是比他大的
// 遞迴處理左右兩邊
void qicksort(int *arr, int left, int right)
{
    // 只有一個不用排序
    if (left < right)
    {
        // 以最右邊基準點
        int flag = arr[right];
        int i = left;
        int j = right - 1;
        // 分別從左右開始找
        // 重複直到 i j 重合
        while(i!=j){
            // 左邊要放小於等於 flag 的，所以找比 flag 大的 ， 找到時 i 指在上面
            while(arr[i]<=flag&&i<j){
                i++;
            }
            while(arr[j]>flag&&i<j){
                // 右邊要放大於 flag 的，所以找比 flag 小的 ， 找到時 j 指在上面
                j--;
            }
            // 交換 i j
            swap(arr[i],arr[j]);
        }
        // i j 重合後與 flag 位置互換，這時flag左邊都是比她小的，右邊都是比他大的
        swap(arr[i],arr[right]);
        // 遞迴處理左右兩邊
        qicksort(arr,left,i-1);
        qicksort(arr,i+1,right);

    }
}
    
    </pre>

</body>

</html>
